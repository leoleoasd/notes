\documentclass{ctexart}
\usepackage[T1]{fontenc}
\usepackage[a4paper,top=1.5cm,bottom=1.5cm,left=2cm,right=2cm,marginparwidth=1.75cm]{geometry}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{outlines}
\usepackage{amsthm}
\usepackage[colorlinks=true]{hyperref}
\usepackage[nameinlink]{cleveref}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\renewcommand{\tableautorefname}{表}
\renewcommand{\equationautorefname}{公式}
\DeclarePairedDelimiter{\set}{\{}{\}}
\DeclarePairedDelimiter{\paren}{(}{)}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\crefname{equation}{方程}{方程}
\crefname{algorithm}{算法}{算法}

\title{算法设计与分析 第一次作业}
\author{卢雨轩 19071125}
% \date{\today}
\ctexset{
    section = {
        titleformat = \raggedright,
        name = {,},
        number = \chinese{section}、
    },
    paragraph = {
        runin = false
    },
    today = small,
    figurename = 图,
    contentsname = 目录,
    tablename = 表,
}

\begin{document}

\maketitle

\section{算法时间复杂性问题}

\begin{outline}[enumerate]
    \1 试证明下面的定理：

        \2 如果$f(n)=O(s(n))$并且$g(n)=O(r(n))$，则$f(n)+g(n)=O(s(n)+r(n))$

        \begin{proof}
            因为
            \begin{equation*}
                f(n)=O(s(n))
            \end{equation*}
            所以我们有：
            \begin{equation}
                \label{eq:1}
                \exists n_0, c_0, \forall n \geq n_0, f(n) \leq c_0s(n)
            \end{equation}
            同理：
            \begin{equation}
                \label{eq:2}
                \exists n_1, c_1, \forall n \geq n_0, g(n) \leq c_1r(n)
            \end{equation}
            由\cref{eq:1}，\cref{eq:2}，我们有：
            \begin{equation*}
                \exists n_0, n_1, c_0, c_1, \forall n \geq n_0 + n_1, f(n) + g(n) \leq \max(c_0,c_1)s(n) + \max(c_0,c_1)r(n)
            \end{equation*}
            所以
            \begin{equation*}
                \exists n_0, c_0, \forall n \geq n_0, f(n) + g(n) \leq c_0(s(n) + g(n))
            \end{equation*}
            \begin{equation*}
                f(n) + g(n) = O(s(n) + r(n))
                \qedhere
            \end{equation*}
        \end{proof}

        \2 如果$f(n)=O(s(n))$并且$g(n)=O(r(n))$,则$f(n)\times g(n)=O(s(n)\times r(n))$
        \begin{proof}
            因为
            \begin{equation*}
                f(n)=O(s(n))
            \end{equation*}
            所以我们有：
            \begin{equation}
                \label{eq:3}
                \exists n_0, c_0, \forall n \geq n_0, f(n) \leq c_0s(n)
            \end{equation}
            同理：
            \begin{equation}
                \label{eq:4}
                \exists n_1, c_1, \forall n \geq n_0, g(n) \leq c_1r(n)
            \end{equation}
            由\cref{eq:3}，\cref{eq:4}，我们有：
            \begin{equation*}
                \exists n_0, n_1, c_0, c_1, \forall n \geq n_0 + n_1, f(n) \times g(n) \leq c_0c_1s(n)r(n)
            \end{equation*}
            所以
            \begin{equation*}
                \exists n_0, c_0, \forall n \geq n_0, f(n) \times g(n) \leq c_0c_1s(n)r(n)
            \end{equation*}
            \begin{equation*}
                f(n) \times g(n) = O(s(n) \times r(n))
                \qedhere
            \end{equation*}
        \end{proof}
    \1 计算规模问题

    假设某算法在输入规模为n时的计算时间复杂度（基本运算的次数）为：
    $T(n)=3\times2^n$，已知在A型计算机上实现并完成输入规模为$n_A$的该算法的时间为T秒，
    现有更先进的B型计算机，其运算速度为A型计算机的64倍。
    试求出若在先进的B型机上运行同一算法在则T秒内能求解输入规模为多大的问题？

    \begin{align*}
        P_B & = 64P_A \\
        T(n_A) & = 3 \times 2^{n_A} \\
        T &= \frac{T(n_A)}{P_A} = \frac{T(n_B)}{P_B} \\
        n_B &= 6+n_A
    \end{align*}

    \1 证明 $\lg(n!) = \theta(n\lg n)$ 
    (注： $\lg(n!) = \theta(n\lg n)$ 等价于 
    $\exists n_0 \in \mathbf{N}^*,c_1,c_2 \in \mathbf{R}^*,  \forall n \geq n_0, 
    c_1 n \lg n \leq \lg(n!) \leq c_2 n \lg n$)

    \begin{proof}
        首先证明$\lg(n!) \leq c_2n\lg n$：
        \begin{align*}
            & \lg(n!) \leq c_2n\lg n \\
            \iff & \lg(1\times2\times3\times\dots\times n) \leq  c_2n\lg n \\
            \iff & \lg1 + \lg2 + \dots + \lg n \leq c_2n \lg n
        \end{align*}
        显然，
        \begin{align*}
            & \lg1 + \lg2 + \dots + \lg n \\
            \leq & \underbrace{\lg n + \lg n + \dots + \lg n}_{n\text{个}} \\
            \leq & n \lg n
        \end{align*}
        所以，$\exists c_2 = 1$使$\forall n \in \mathbf{N}^*, \lg1 + \lg2 + \dots + \lg n \leq c_2 n \lg n$ \\
        所以，$\exists c_2 = 1$使$\forall n \in \mathbf{N}^*, \lg(n!) \leq c_2n\lg n$。
        
        再证明$c_1n\lg n \leq \lg(n!)$，设$n_1 = \ceil*{\frac{n}{2}}$：
        \begin{align*}
            & \lg(n!) \\
            = & \lg(1\times2\times3\times\dots\times n) \\
            = & \lg1 + \lg2 + \dots + \lg (n_1) + \lg (n_1 + 1) + \dots + \lg n \\
            \geq & \lg (n_1) + \lg (n_1 + 1) + \dots + \lg n \\
            \geq & \underbrace{\lg (n_1) + \lg (n_1) + \dots + \lg (n_1)}_{n_1\text{个}} \\
            \geq & n_1 \lg n_1 \\
            = & \ceil*{\frac{n}{2}} \lg \ceil*{\frac{n}{2}}
        \end{align*}
        不妨设$c_1 = 0.25$。当$n \geq 4$ 时：
        \begin{align*}
            (1-2c_1)\lg n - \lg 2 = 0.5 \lg n - \lg 2 \geq & 0 \\
            (1-2c) \lg n \geq & \lg 2 \\
            \lg n - \lg 2 \geq & 2c_1 \lg n \\
            \lg(n/2) \geq & 2c_1 \lg n \\
            \frac{1}{2} \lg(\frac{n}{2}) \geq & c_1 \lg n \\
            \frac{n}{2} \lg(\frac{n}{2}) \geq & c_1 n \lg n \\
            \ceil*{\frac{n}{2}} \lg \ceil*{\frac{n}{2}} & \geq c_1 n \lg n
        \end{align*}
        所以，对于$n_0 = 4$，对于$\forall n \geq n_0$，
        $\exists c_1 = 0.25$使$c_1 n \lg n \leq \lg(n!)$
        
        综上，$\exists n_0 = 4, c_1 = 0.25, c_2 = 1, \forall n \geq n_0, c_1 n \lg n \leq \lg(n!) \leq c_2 n \lg n$。 \\
        即$\lg(n!) = \theta(n \lg n)$
    \end{proof}


\end{outline}
 

\section{算法设计与分析问题}

\begin{outline}[enumerate]

\1 最大值和最小值问题的最优算法

给定n个实数存放于一维数组A中，试设计一个算法在最坏情况下用3n/2-2次的比较找出A中的最大值和最小值（为简化，可假设n为偶数）。

答：见\cref{algo:1}

\begin{algorithm}
    \caption{Find the max and min value of an array}
    \begin{algorithmic}[1]
        \label{algo:1}
        \Procedure{Find}{$A$} \Comment{An array $A$}
            \State $mins \gets \text{Empty Array}$
            \State $maxs \gets \text{Empty Array}$
            \For{$i, j \gets \text{paired values from A}$} \Comment{Go through array A and divide it into two value sets.}
                \If{$i \ge j$}
                    \State $mins.PushBack(j) $
                    \State $maxs.PushBack(i) $
                \Else
                    \State $mins.PushBack(i) $
                    \State $maxs.PushBack(j) $
                \EndIf
            \EndFor
            \If{$A$ has not iterated value.}
                \State $mins.PushBack(\text{not iterated value})$
                \State $maxs.PushBack(\text{not iterated value})$
            \EndIf
            \State $min \gets mins_0$
            \State $max \gets maxs_0$
            \For{$i \gets 1 \text{ to } |mins|-1$} \Comment{Find the minimal value from mins using regular way}
                \If{$mins_i < min$}
                    \State $min \gets mins_i$
                \EndIf
            \EndFor
            \For{$i \gets 1 \text{ to } |maxs|-1$} \Comment{Find the maxnimal value from maxs using regular way}
                \If{$maxs_i > min$}
                    \State $max \gets maxs_i$
                \EndIf
            \EndFor
            % \While{$|mins| \neq 1$} 
            %     \Comment{Iterate mins, reduce their size by half.}
            %     \State $mins_0 \gets \text{Empty Array}$
            %     \State $maxs_0 \gets \text{Empty Array}$
            %     \For{$i, j \gets \text{paired values from } mins$}
            %         \If{$i \ge j$}
            %             \State $mins_0.PushBack(j) $
            %         \Else
            %             \State $mins_0.PushBack(i) $
            %         \EndIf
            %     \EndFor
            %     \If{$mins$ has not iterated value}
            %         \State $mins_0 \gets \text{not iterated value}$
            %     \EndIf
            %     \For{$i, j \gets \text{paired values from } maxs$} \Comment{Do the same thing}
            %         \If{$i \ge j$}
            %             \State $maxs_0.PushBack(j) $
            %         \Else
            %             \State $maxs_0.PushBack(i) $
            %         \EndIf
            %     \EndFor
            %     \If{$maxs$ has not iterated value}
            %         \State $maxs_0 \gets \text{not iterated value}$
            %     \EndIf
            %     \State $maxs \gets maxs_0$
            %     \State $mins \gets mins_0$
            % \EndWhile
            \State \textbf{return} $max, min$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\1 聪明的判定问题

给定n个正整数，它们存放于一维数组S中，且S中的正整数从小到大有序排列，
试设计一个算法，判定S中是否存在这样两个整数a、b，其和恰好与给定值x相等（要求算法的时间复杂性为O(n)）。

答：见\cref{algo:2}

\begin{algorithm}
    \caption{Test if an array S has two value that sum to $x$}
    \begin{algorithmic}[1]
        \label{algo:2}
        \Procedure{Test}{$S$} \Comment{An array $S$}
            \State $i \gets 0$
            \State $j \gets |S| - 1$
            \While{$i \leq j$}
                \If{$S_i + S_j = x$}
                    \State \textbf{return} True
                \ElsIf{$S_i + S_j < x$}
                    \State $i \gets i + 1$
                \Else
                    \State $j \gets j - 1$
                \EndIf
            \EndWhile
            \State \textbf{return} False
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\1 快速排序问题

著名的快速排序算法对于计算机类专业的学生已不陌生，算法是递归实现的。请按照快速排序的思想，设计一个非递归的（即迭代的）快速排序算法。（提示：可利用栈）。

答：见\cref{algo:3}

\begin{algorithm}
    \caption{Non-recursive quick sort}
    \begin{algorithmic}[1]
        \label{algo:3}
        \Procedure{Test}{$S$} \Comment{An array $arr$}
            \State $beq, end \gets \text{Empty Stack}$
            \State $beq.Push(0)$
            \State $end.Push(|arr|)$
            % \State $i \gets 0$
            \While{$beq$ not empty}
                \State $L \gets beq.top()$
                \State $R \gets end.top() - 1$
                \If{$L < R$} \Comment{Partition [L, R)}
                    \State $piv \gets arr_L$
                    \While{$L < R$} \Comment{Move piv around}
                        \While{$arr_R \geq piv \text{ and } L < R$}
                            \State $R \gets R - 1$
                        \EndWhile
                        \If{$L < R$}
                            \State $arr_L = arr_R$
                            \State $L \gets L + 1$
                        \EndIf
                        \While{$arr_L \leq piv \text{ and } L < R$}
                            \State $L \gets L - 1$
                        \EndWhile
                        \If{$L < R$}
                            \State $arr_R = arr_L$
                            \State $R \gets R - 1$
                        \EndIf
                    \EndWhile \Comment{Now, piv should get to L.}
                    \State $arr_L \gets piv$ \Comment{And we should partition [L+1, end.top()) and [beq.top(), L)}
                    \State $beq.push(L + 1)$ \Comment{Because we didn't pop beq, we just need to push L+1}
                    \State $temp \gets end.pop()$ \Comment{And insert current L under end.top()}
                    \State $end.push(L)$
                    \State $end.push(temp)$
                \Else
                    \State $beq.pop()$
                    \State $end.pop()$
                \EndIf
            \EndWhile
        \EndProcedure
    \end{algorithmic}
\end{algorithm}
\end{outline}
\end{document}
